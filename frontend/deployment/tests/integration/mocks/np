#!/bin/bash
# =============================================================================
# np CLI mock for integration tests
#
# This mock intercepts all np commands EXCEPT 'np service workflow exec'
# which is passed through to the real np CLI.
#
# Mock responses are configured via environment variables:
#   NP_MOCK_DIR      - Directory containing mock response files
#   NP_MOCK_CONFIG   - JSON file with mock configuration for current test step
#   NP_REAL_CLI      - Path to the real np CLI (default: uses which np from original PATH)
# =============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Build the command key from arguments (e.g., "np provider list", "np scope get")
# This extracts only the subcommands (no flags) for matching
build_command_key() {
  local key="np"
  local skip_next=false
  for arg in "$@"; do
    # Skip flag values (argument after a flag)
    if [ "$skip_next" = true ]; then
      skip_next=false
      continue
    fi
    # Skip flags and mark to skip their values
    if [[ "$arg" == --* ]]; then
      skip_next=true
      continue
    fi
    if [[ "$arg" == -* ]]; then
      skip_next=true
      continue
    fi
    key="$key $arg"
  done
  echo "$key"
}

# Build full command string with flags for error messages
build_full_command() {
  local cmd="np"
  local i=1
  while [ $i -le $# ]; do
    local arg="${!i}"
    cmd="$cmd $arg"
    i=$((i + 1))
  done
  echo "$cmd"
}

# Check if this is a workflow exec command
is_workflow_exec() {
  local args="$*"
  if [[ "$args" == *"service workflow exec"* ]] || [[ "$args" == *"service"*"workflow"*"exec"* ]]; then
    return 0
  fi
  return 1
}

# If this is 'np service workflow exec', pass through to real CLI
if is_workflow_exec "$@"; then
  if [ -n "$NP_REAL_CLI" ] && [ -x "$NP_REAL_CLI" ]; then
    exec "$NP_REAL_CLI" "$@"
  else
    # Try to find np in original PATH (before mock was added)
    if [ -n "$NP_ORIGINAL_PATH" ]; then
      REAL_NP=$(PATH="$NP_ORIGINAL_PATH" which np 2>/dev/null)
      if [ -n "$REAL_NP" ] && [ -x "$REAL_NP" ]; then
        exec "$REAL_NP" "$@"
      fi
    fi
    echo "Error: Cannot find real np CLI for workflow exec" >&2
    echo "Set NP_REAL_CLI or NP_ORIGINAL_PATH environment variable" >&2
    exit 1
  fi
fi

# For all other commands, use mock responses
if [ -z "$NP_MOCK_CONFIG" ]; then
  echo "Error: NP_MOCK_CONFIG not set" >&2
  exit 1
fi

if [ ! -f "$NP_MOCK_CONFIG" ]; then
  echo "Error: Mock config file not found: $NP_MOCK_CONFIG" >&2
  exit 1
fi

# Build command key (for matching) and full command (for error messages)
CMD_KEY=$(build_command_key "$@")
FULL_CMD=$(build_full_command "$@")

# Get the step index (np_mocks are defined per step)
STEP_INDEX="${NP_MOCK_STEP_INDEX:-0}"

# Look up mock configuration for this command (mocks are in .steps[N].np_mocks)
MOCK_RESPONSE_FILE=$(jq -r --arg key "$CMD_KEY" --argjson idx "$STEP_INDEX" '.steps[$idx].np_mocks[$key].response_file // empty' "$NP_MOCK_CONFIG")
MOCK_EXIT_CODE=$(jq -r --arg key "$CMD_KEY" --argjson idx "$STEP_INDEX" '.steps[$idx].np_mocks[$key].exit_code // 0' "$NP_MOCK_CONFIG")

if [ -z "$MOCK_RESPONSE_FILE" ]; then
  echo "Error: No mock configured for command" >&2
  echo "" >&2
  echo "  Full command: $FULL_CMD" >&2
  echo "  Match key:    $CMD_KEY" >&2
  echo "  Step index:   $STEP_INDEX" >&2
  echo "" >&2
  echo "Available mocks for this step:" >&2
  jq -r --argjson idx "$STEP_INDEX" '.steps[$idx].np_mocks // {} | keys[]' "$NP_MOCK_CONFIG" | sed 's/^/  - /' >&2
  exit 1
fi

# Output mock response
MOCK_FILE_PATH="$NP_MOCK_DIR/$MOCK_RESPONSE_FILE"
if [ -f "$MOCK_FILE_PATH" ]; then
  cat "$MOCK_FILE_PATH"
else
  echo "Error: Mock response file not found: $MOCK_FILE_PATH" >&2
  exit 1
fi

exit "${MOCK_EXIT_CODE:-0}"
