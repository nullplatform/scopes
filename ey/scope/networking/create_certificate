#!/bin/bash

set -euo pipefail

# Skip certificate creation if DEPLOYMENT_ID env variable is set
if [ -n "${DEPLOYMENT_ID:-}" ]; then
    echo "DEPLOYMENT_ID env variable is set, skipping certificate creation"
    # Do nothing and finish successfully
    echo "Certificate workflow skipped"
    exit 0
fi

# Extract variables from CONTEXT
DEPLOYMENT_ID=$(echo "$CONTEXT" | jq -r '.scope.id')
CERTIFICATE_NAME=$(echo "$CONTEXT" | jq -r '.scope.domain')

# Required environment variables
: "${KEYVAULT_NAME:?Environment variable KEYVAULT_NAME not set}"
: "${ANSIBLE_TOWER_URL:?Environment variable ANSIBLE_TOWER_URL not set}"
: "${ANSIBLE_TOWER_TEMPLATE_ID:?Environment variable ANSIBLE_TOWER_TEMPLATE_ID not set}"
: "${APPLICATION_CONTACT:?Environment variable APPLICATION_CONTACT not set}"
: "${CERTIFICATE_OWNER:?Environment variable CERTIFICATE_OWNER not set}"
: "${CERTIFICATE_DOMAIN_NAME:?Environment variable CERTIFICATE_DOMAIN_NAME not set}"
: "${PROJECT_CHARGECODE:?Environment variable PROJECT_CHARGECODE not set}"
: "${ENVIRONMENT:?Environment variable ENVIRONMENT not set}"
: "${SMU_CHARGECODE:?Environment variable SMU_CHARGECODE not set}"
: "${TENANT_NAME:?Environment variable TENANT_NAME not set}"
: "${GATEWAY_NAMESPACE:?Environment variable GATEWAY_NAMESPACE not set}"

# Optional environment variables with defaults
DRY_RUN="${DRY_RUN:-false}"
POLL_INTERVAL="${POLL_INTERVAL:-10}"
TIMEOUT="${TIMEOUT:-1800}"
CERT_WAIT_TIMEOUT="${CERT_WAIT_TIMEOUT:-60}"

# Set domain name
DOMAIN_NAME="${CERTIFICATE_DOMAIN_NAME}"

# Retrieve Ansible credentials from KeyVault
echo "Retrieving Ansible credentials from KeyVault..."
ANSIBLE_TOWER_USERNAME=$(az keyvault secret show --vault-name "${KEYVAULT_NAME}" --name "ansibleUser" --query "value" -o tsv)
ANSIBLE_TOWER_PASSWORD=$(az keyvault secret show --vault-name "${KEYVAULT_NAME}" --name "ansiblePassword" --query "value" -o tsv)

if [ -z "${ANSIBLE_TOWER_USERNAME}" ] || [ -z "${ANSIBLE_TOWER_PASSWORD}" ]; then
    echo "ERROR: Failed to retrieve Ansible credentials from KeyVault"
    exit 1
fi

# Build EXTRA_VARS
EXTRA_VARS=$(cat <<EOF
{
  "var_application_contact": "${APPLICATION_CONTACT}",
  "var_certificate_authority": 1,
  "var_certificate_name": "${CERTIFICATE_NAME}",
  "var_certificate_owner": "${CERTIFICATE_OWNER}",
  "var_deployment_id": "${DEPLOYMENT_ID}",
  "var_device_input": [
    {
      "ApplicationInput": [
        {
          "PasswordRequired": 1,
          "TenantName": "${TENANT_NAME}"
        }
      ],
      "DeviceName": "${KEYVAULT_NAME}",
      "PlatformType": "AzureKeyVault"
    }
  ],
  "var_domain_name": "${DOMAIN_NAME}",
  "var_environment": "${ENVIRONMENT}",
  "var_project_chargecode": "${PROJECT_CHARGECODE}",
  "var_provisioning_model": "Full",
  "var_request_type": "create",
  "var_smu_chargecode": "${SMU_CHARGECODE}"
}
EOF
)

echo "Generated EXTRA_VARS:"
echo "${EXTRA_VARS}"
echo ""

if [ "$DRY_RUN" = "true" ]; then
    echo "DRY RUN: Would execute the following curl command:"
    echo "curl -s -k \\"
    echo "  -u [USERNAME]:[PASSWORD] \\"
    echo "  -H \"Content-Type: application/json\" \\"
    echo "  -X POST \\"
    echo "  \"${ANSIBLE_TOWER_URL}/api/v2/job_templates/${ANSIBLE_TOWER_TEMPLATE_ID}/launch/\" \\"
    echo "  -d '{\"extra_vars\": ${EXTRA_VARS}}'"
else
    auth_header="Authorization: Basic $(echo -n "${ANSIBLE_TOWER_USERNAME}:${ANSIBLE_TOWER_PASSWORD}" | base64)"
    
    LAUNCH_RESPONSE=$(curl -s -k \
      -H "${auth_header}" \
      -H "Content-Type: application/json" \
      -X POST \
      "${ANSIBLE_TOWER_URL}/api/v2/job_templates/${ANSIBLE_TOWER_TEMPLATE_ID}/launch/" \
      -d "{\"extra_vars\": ${EXTRA_VARS}}")

    JOB_ID=$(echo "${LAUNCH_RESPONSE}" | jq -r '.id')

    if [ "${JOB_ID}" = "null" ] || [ -z "${JOB_ID}" ]; then
        echo "ERROR: Failed to launch job"
        echo "${LAUNCH_RESPONSE}"
        exit 1
    fi

    echo "Job launched successfully. Job ID: ${JOB_ID}"
    
    POLL_INTERVAL="${POLL_INTERVAL:-10}"
    TIMEOUT="${TIMEOUT:-1800}"
    START_TIME=$(date +%s)

    echo "Monitoring job status..."
    while true; do
        CURRENT_TIME=$(date +%s)
        ELAPSED=$((CURRENT_TIME - START_TIME))
        
        if [ ${ELAPSED} -gt ${TIMEOUT} ]; then
            echo "ERROR: Job timed out after ${TIMEOUT} seconds"
            exit 1
        fi
        
        STATUS_RESPONSE=$(curl -s -k \
            -H "${auth_header}" \
            "${ANSIBLE_TOWER_URL}/api/v2/jobs/${JOB_ID}/")
        
        STATUS=$(echo "${STATUS_RESPONSE}" | jq -r '.status')
        
        echo "Job ${JOB_ID} status: ${STATUS} (elapsed: ${ELAPSED}s)"
        
        case "${STATUS}" in
            "successful")
                echo "Job completed successfully!"
                break
                ;;
            "failed"|"error"|"canceled")
                echo "ERROR: Job failed with status: ${STATUS}"
                echo "Getting job output..."
                curl -s -k \
                    -H "${auth_header}" \
                    "${ANSIBLE_TOWER_URL}/api/v2/jobs/${JOB_ID}/stdout/?format=txt_download" \
                    | tail -50
                exit 1
                ;;
            "pending"|"waiting"|"running")
                sleep ${POLL_INTERVAL}
                ;;
            *)
                echo "Unknown job status: ${STATUS}"
                sleep ${POLL_INTERVAL}
                ;;
        esac
    done
    
    # Wait for certificate to be available in KeyVault
    echo "Waiting for certificate to be available in KeyVault..."
    KV_CERT_NAME=$(echo "${CERTIFICATE_NAME}" | sed 's/\./-/g')
    WAIT_COUNT=0
    MAX_WAIT="${CERT_WAIT_TIMEOUT:-60}"
    
    while [ ${WAIT_COUNT} -lt ${MAX_WAIT} ]; do
        if az keyvault certificate show --vault-name "${KEYVAULT_NAME}" --name "${KV_CERT_NAME}" >/dev/null 2>&1; then
            echo "Certificate found in KeyVault: ${KV_CERT_NAME}"
            break
        fi
        echo "Waiting for certificate... (attempt $((WAIT_COUNT + 1))/${MAX_WAIT})"
        sleep 10
        WAIT_COUNT=$((WAIT_COUNT + 1))
    done
    
    if [ ${WAIT_COUNT} -ge ${MAX_WAIT} ]; then
        echo "ERROR: Certificate not found in KeyVault after waiting"
        exit 1
    fi
    
    # Retrieve certificate data
    echo "Downloading certificate data from KeyVault..."
    CERT_DATA=$(az keyvault secret show --vault-name "${KEYVAULT_NAME}" --name "${KV_CERT_NAME}" --query "value" -o tsv)
    
    if [ -z "${CERT_DATA}" ]; then
        echo "ERROR: Failed to retrieve certificate data from KeyVault"
        exit 1
    fi
    
    echo "Certificate retrieved successfully from KeyVault"
    
    # Extract certificate and private key from PKCS#12 data
    echo "Extracting certificate and private key..."
    TEMP_DIR=$(mktemp -d)
    PKCS12_FILE="${TEMP_DIR}/cert-${DEPLOYMENT_ID}.p12"
    CERT_FILE="${TEMP_DIR}/cert-${DEPLOYMENT_ID}.pem"
    KEY_FILE="${TEMP_DIR}/key-${DEPLOYMENT_ID}.pem"
    CHAIN_FILE="${TEMP_DIR}/chain-${DEPLOYMENT_ID}.pem"
    
    # Decode base64 and save as PKCS#12
    echo "${CERT_DATA}" | base64 -d > "${PKCS12_FILE}"
    
    # Extract private key
    openssl pkcs12 -in "${PKCS12_FILE}" -nocerts -nodes -passin pass: -out "${KEY_FILE}" 2>/dev/null
    
    # Extract certificate
    openssl pkcs12 -in "${PKCS12_FILE}" -clcerts -nokeys -passin pass: -out "${CERT_FILE}" 2>/dev/null
    
    # Extract certificate chain
    openssl pkcs12 -in "${PKCS12_FILE}" -cacerts -nokeys -passin pass: -out "${CHAIN_FILE}" 2>/dev/null
    
    # Clean up the PEM files (remove extra text, keep only PEM blocks)
    grep -A 100 "BEGIN CERTIFICATE" "${CERT_FILE}" | grep -B 100 "END CERTIFICATE" > "${CERT_FILE}.clean" || true
    grep -A 100 "BEGIN PRIVATE KEY\|BEGIN RSA PRIVATE KEY" "${KEY_FILE}" | grep -B 100 "END PRIVATE KEY\|END RSA PRIVATE KEY" > "${KEY_FILE}.clean" || true
    
    # Combine certificate with chain for full certificate
    cat "${CERT_FILE}.clean" > "${TEMP_DIR}/fullchain-${DEPLOYMENT_ID}.pem"
    if [ -s "${CHAIN_FILE}" ]; then
        grep -A 100 "BEGIN CERTIFICATE" "${CHAIN_FILE}" | grep -B 100 "END CERTIFICATE" >> "${TEMP_DIR}/fullchain-${DEPLOYMENT_ID}.pem" || true
    fi
    
    # Create Kubernetes TLS secret
    SECRET_NAME="tls-${DEPLOYMENT_ID}"
    GATEWAY_NAMESPACE="${GATEWAY_NAMESPACE}"
    SECRET_NAMESPACE="${SECRET_NAMESPACE:-${GATEWAY_NAMESPACE}}"
    
    echo "Creating Kubernetes TLS secret: ${SECRET_NAME} in namespace: ${SECRET_NAMESPACE}"
    
    # Delete existing secret if it exists
    kubectl delete secret "${SECRET_NAME}" -n "${SECRET_NAMESPACE}" 2>/dev/null || true
    
    # Create new TLS secret
    kubectl create secret tls "${SECRET_NAME}" \
        --cert="${TEMP_DIR}/fullchain-${DEPLOYMENT_ID}.pem" \
        --key="${KEY_FILE}.clean" \
        -n "${SECRET_NAMESPACE}"
    
    # Add annotations to the secret
    kubectl annotate secret "${SECRET_NAME}" -n "${SECRET_NAMESPACE}" \
        "cert-manager.io/certificate-name=${CERTIFICATE_NAME}" \
        "cert-manager.io/issuer-kind=AnsibleTowerIssuer" \
        "cert-manager.io/issuer-group=pki.ey.com" \
        "pki.ey.com/certificate-name=${CERTIFICATE_NAME}" \
        "pki.ey.com/keyvault-name=${KEYVAULT_NAME}"
    
    echo "TLS secret created successfully"
    
    # Attach certificate to Gateway API gateway (commented out for now)
    # GATEWAY_NAME="${GATEWAY_NAME:-gateway-public}"
    # 
    # echo "Adding certificate to gateway: ${GATEWAY_NAME} in namespace: ${GATEWAY_NAMESPACE}"
    # 
    # if kubectl get gateway "${GATEWAY_NAME}" -n "${GATEWAY_NAMESPACE}" >/dev/null 2>&1; then
    #     # Get current certificateRefs
    #     CURRENT_REFS=$(kubectl get gateway "${GATEWAY_NAME}" -n "${GATEWAY_NAMESPACE}" -o jsonpath='{.spec.listeners[0].tls.certificateRefs}')
    #     
    #     # Create a patch to add our certificate to the existing certificateRefs array
    #     PATCH_FILE="${TEMP_DIR}/gateway-patch-${DEPLOYMENT_ID}.json"
    #     cat > "${PATCH_FILE}" <<EOF
    # [
    #   {
    #     "op": "add",
    #     "path": "/spec/listeners/0/tls/certificateRefs/-",
    #     "value": {
    #       "group": "",
    #       "kind": "Secret",
    #       "name": "${SECRET_NAME}"
    #     }
    #   }
    # ]
    # EOF
    #     
    #     # Apply the JSON patch to add our certificate without removing existing ones
    #     kubectl patch gateway "${GATEWAY_NAME}" -n "${GATEWAY_NAMESPACE}" --type=json --patch-file="${PATCH_FILE}"
    #     echo "Gateway updated with additional certificate: ${SECRET_NAME}"
    # else
    #     echo "WARNING: Gateway '${GATEWAY_NAME}' not found in namespace '${GATEWAY_NAMESPACE}'"
    # fi
    
    # Cleanup temporary files
    # rm -rf "${TEMP_DIR}"
    
    echo "Certificate workflow completed successfully!"
fi
