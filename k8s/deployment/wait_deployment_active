#!/bin/bash

MAX_ITERATIONS=$(( TIMEOUT / 10 ))
K8S_DEPLOYMENT_NAME="d-$SCOPE_ID-$DEPLOYMENT_ID"
iteration=0
LATEST_TIMESTAMP=""
SKIP_DEPLOYMENT_STATUS_CHECK="${SKIP_DEPLOYMENT_STATUS_CHECK:=false}"

while true; do
    ((iteration++))
    if [ $iteration -gt $MAX_ITERATIONS ]; then
        echo "ERROR: Timeout waiting for deployment. Maximum iterations (${MAX_ITERATIONS}) reached."
        exit 1
    fi
    
    echo "Checking deployment status (attempt $iteration/$MAX_ITERATIONS)..."
    D_STATUS=$(np deployment read --id $DEPLOYMENT_ID --api-key $NP_API_KEY --query .status 2>&1) || {
        echo "ERROR: Failed to read deployment status"
        echo "NP CLI error: $D_STATUS"
        exit 1
    }
    
    if [[ -z "$D_STATUS" ]] || [[ "$D_STATUS" == "null" ]]; then
        echo "ERROR: Deployment status not found for ID $DEPLOYMENT_ID"
        exit 1
    fi

    if [ "$SKIP_DEPLOYMENT_STATUS_CHECK" != true ]; then
        if [[ $D_STATUS != "running" && $D_STATUS != "waiting_for_instances" ]]; then
            echo "Deployment it's not running anymore [$D_STATUS]"
            exit 1
        fi
    fi

    deployment_status=$(kubectl get deployment "$K8S_DEPLOYMENT_NAME" -n "$K8S_NAMESPACE" -o json 2>/dev/null)
    if [ $? -ne 0 ]; then
        echo "Error: Deployment '$K8S_DEPLOYMENT_NAME' not found in namespace '$K8S_NAMESPACE'"
        exit 1
    fi
    desired=$(echo "$deployment_status" | jq '.spec.replicas')
    current=$(echo "$deployment_status" | jq '.status.availableReplicas // 0')
    updated=$(echo "$deployment_status" | jq '.status.updatedReplicas // 0')
    ready=$(echo "$deployment_status" | jq '.status.readyReplicas // 0')
    echo "$(date): Iteration $iteration - Deployment status - Available: $current/$desired, Updated: $updated/$desired, Ready: $ready/$desired"

    if [ "$desired" = "$current" ] && [ "$desired" = "$updated" ] && [ "$desired" = "$ready" ] && [ "$desired" -gt 0 ]; then
        echo "Success: All pods in deployment '$K8S_DEPLOYMENT_NAME' are available and ready!"
        break
    fi

    POD_SELECTOR="deployment_id=${DEPLOYMENT_ID}"
    POD_NAMES=$(kubectl get pods -n $K8S_NAMESPACE -l $POD_SELECTOR -o jsonpath='{.items[*].metadata.name}')
    # Get events for the deployment first
    DEPLOYMENT_EVENTS=$(kubectl get events -n $K8S_NAMESPACE --field-selector involvedObject.kind=Deployment,involvedObject.name=$K8S_DEPLOYMENT_NAME -o json)
    
    ALL_EVENTS="$DEPLOYMENT_EVENTS"

    for POD in $POD_NAMES; do
        echo "Checking events for pod: $POD"
        POD_EVENTS=$(kubectl get events -n $K8S_NAMESPACE --field-selector involvedObject.kind=Pod,involvedObject.name=$POD -o json)
        # Combine events using jq
        if [ ! -z "$POD_EVENTS" ] && [ "$POD_EVENTS" != "{}" ]; then
        ALL_EVENTS=$(echo "$ALL_EVENTS" "$POD_EVENTS" | jq -s '.[0].items = (.[0].items + .[1].items) | .[0]')
        fi
    done
    
    PROCESSED_EVENTS=$(echo "$ALL_EVENTS" | jq '.items = (.items | map(. + {
        effectiveTimestamp: (
        if .eventTime then .eventTime 
        elif .lastTimestamp then .lastTimestamp 
        elif .firstTimestamp then .firstTimestamp
        else .metadata.creationTimestamp
        end
        )
    }))')
    
    # Find the newest timestamp in all events
    NEWEST_TIMESTAMP=$(echo "$PROCESSED_EVENTS" | jq -r '.items | map(.effectiveTimestamp) | max // empty')
    
    # Process events with jq, showing only events newer than what we've seen
    NEW_EVENTS=$(echo "$PROCESSED_EVENTS" | jq -r --arg timestamp "$LATEST_TIMESTAMP" '
        .items | 
        sort_by(.effectiveTimestamp) | 
        .[] | 
        select($timestamp == "" or (.effectiveTimestamp > $timestamp)) | 
        "\(.effectiveTimestamp) [\(.type)] \(.involvedObject.kind)/\(.involvedObject.name): \(.reason) - \(.message)"
    ')
    
    # If we have new events, show them and update the timestamp
    if [ ! -z "$NEW_EVENTS" ]; then
        echo "$NEW_EVENTS"
        # Store the newest timestamp for next iteration
        LATEST_TIMESTAMP="$NEWEST_TIMESTAMP"
        echo "Updated timestamp to: $LATEST_TIMESTAMP"
        
        # Check for BackOff or failure events and get more details
        if echo "$NEW_EVENTS" | grep -E "(BackOff|Failed|Error|CrashLoopBackOff|Unhealthy)" > /dev/null 2>&1; then
            # Wrap all enhanced logging in a subshell to catch any errors
            (
                set +e  # Don't exit on error for this section
                echo ""
                echo "=== DETECTED CONTAINER ISSUES - GATHERING ADDITIONAL CONTEXT ==="
                
                for POD in $POD_NAMES; do
                    # Get pod status details
                    POD_STATUS=$(kubectl get pod "$POD" -n "$K8S_NAMESPACE" -o json 2>/dev/null)
                    if [ $? -eq 0 ] && [ ! -z "$POD_STATUS" ]; then
                        # Check container statuses with error handling
                        CONTAINER_STATUSES=$(echo "$POD_STATUS" 2>/dev/null | jq -r '.status.containerStatuses[]? | 
                            select(.state.waiting or .state.terminated) | 
                            "Container: \(.name) - State: \(if .state.waiting then "Waiting (\(.state.waiting.reason)): \(.state.waiting.message // "No message")" elif .state.terminated then "Terminated (Exit Code: \(.state.terminated.exitCode)): \(.state.terminated.reason // "Unknown reason")" else "Unknown" end) - RestartCount: \(.restartCount)"' 2>/dev/null || echo "")
                        
                        if [ ! -z "$CONTAINER_STATUSES" ]; then
                            echo ""
                            echo "Pod: $POD - Container Status Issues:"
                            echo "$CONTAINER_STATUSES"
                            
                            # Get last termination info if available
                            LAST_TERMINATION=$(echo "$POD_STATUS" 2>/dev/null | jq -r '.status.containerStatuses[]? | 
                                select(.lastState.terminated) | 
                                "Container: \(.name) - Last Termination: Exit Code: \(.lastState.terminated.exitCode), Reason: \(.lastState.terminated.reason // "Unknown"), Message: \(.lastState.terminated.message // "No message")"' 2>/dev/null || echo "")
                            
                            if [ ! -z "$LAST_TERMINATION" ]; then
                                echo ""
                                echo "Previous Termination Details:"
                                echo "$LAST_TERMINATION"
                            fi
                            
                            
                            # Get pod describe output for more details
                            echo ""
                            echo "=== Pod Describe Output (Events and Conditions) ==="
                            kubectl describe pod "$POD" -n "$K8S_NAMESPACE" 2>/dev/null | grep -A 20 -E "(Events:|Conditions:)" 2>/dev/null || echo "Unable to describe pod"
                        fi
                    else
                        echo "Unable to get status for pod: $POD"
                    fi
                done
                echo "=== END OF ADDITIONAL CONTEXT ==="
                echo ""
            ) 2>&1 || echo "Warning: Error occurred while gathering additional context, but continuing..."
        fi
    fi

    sleep 10
done
