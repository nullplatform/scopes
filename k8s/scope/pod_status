#!/bin/bash

set -euo pipefail

# Configuration
NAMESPACE="${K8S_NAMESPACE:-default}"
SCOPE_ID="${SCOPE_ID:-}"
NETWORK_CHECK="${NETWORK_CHECK:-true}"  # Set to true to enable network diagnostics

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

print_success() {
    echo -e "${GREEN}âœ“${NC} $1"
}

print_error() {
    echo -e "${RED}âœ—${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}âš ${NC} $1"
}

print_info() {
    echo -e "${CYAN}â„¹${NC} $1"
}

# Validate inputs
if [ -z "$SCOPE_ID" ] || [ -z "$NAMESPACE" ]; then
    print_error " ERROR: Missing required environment variables"
    echo "   SCOPE_ID: ${SCOPE_ID:-<not set>}"
    echo "   NAMESPACE: ${NAMESPACE:-<not set>}"
    jq -cn '{
      error: "Missing SCOPE_ID or NAMESPACE",
      success: false
    }'
    exit 1
fi

print_info "ğŸ” Checking pods with scope_id=$SCOPE_ID in namespace=$NAMESPACE"
echo ""

# Check if namespace exists
if ! kubectl get namespace "$NAMESPACE" &>/dev/null; then
    print_error " ERROR: Namespace '$NAMESPACE' does not exist"
    jq -cn \
        --arg ns "$NAMESPACE" \
        '{
          error: "Namespace does not exist",
          namespace: $ns,
          success: false
        }'
    exit 1
fi

# Get pods with the specified label
PODS_JSON=$(kubectl get pods -n "$NAMESPACE" -l "scope_id=$SCOPE_ID" -o json 2>/dev/null || echo '{"items":[]}')

# Check if any pods were found
POD_COUNT=$(echo "$PODS_JSON" | jq '.items | length')

if [ "$POD_COUNT" -eq 0 ]; then
    print_warning " WARNING: No pods found with label scope_id=$SCOPE_ID"
    jq -cn \
        --arg scope_id "$SCOPE_ID" \
        --arg namespace "$NAMESPACE" \
        '{
          error: "No pods found with the specified label",
          success: false,
          scope_id: $scope_id,
          namespace: $namespace,
          pod_count: 0
        }'
    exit 1
fi

# Parse pod information
POD_DATA=$(echo "$PODS_JSON" | jq -r '
  .items[] |
  [
    .metadata.name,
    .status.phase,
    (.status.containerStatuses // [] | map(.ready) | if . == [] then "N/A" else (if all then "Ready" else "NotReady" end) end),
    (.status.containerStatuses // [] | map(.restartCount) | add // 0),
    (.status.conditions // [] | map(select(.type == "Ready")) | .[0].status // "Unknown")
  ] | @tsv
')

# Count pods by phase
PHASE_SUMMARY=$(echo "$PODS_JSON" | jq -r '
  .items |
  group_by(.status.phase) |
  map({
    phase: .[0].status.phase,
    count: length
  }) |
  sort_by(.phase)
')

# Display summary
print_info "ğŸ“Š PODS SUMMARY"
echo "$PHASE_SUMMARY" | jq -r '.[] | "  \(.phase): \(.count) pod(s)"'
print_info "Total pods found: $POD_COUNT"

# Display detailed pod status
print_info "ğŸ“‹ DETAILED POD STATUS"
printf "%-50s %-12s %-12s %-10s %-10s\n" "POD NAME" "PHASE" "READY" "RESTARTS" "CONDITION"
printf "%-50s %-12s %-12s %-10s %-10s\n" "$(printf '%.0sâ”€' {1..50})" "$(printf '%.0sâ”€' {1..12})" "$(printf '%.0sâ”€' {1..12})" "$(printf '%.0sâ”€' {1..10})" "$(printf '%.0sâ”€' {1..10})"

while IFS=$'\t' read -r name phase ready restarts condition; do
    # Color code based on status
    if [ "$phase" == "Running" ] && [ "$ready" == "Ready" ]; then
        color="$GREEN"
    elif [ "$phase" == "Pending" ] || [ "$phase" == "ContainerCreating" ]; then
        color="$YELLOW"
    else
        color="$RED"
    fi

    echo -e "${color}$(printf "%-50s %-12s %-12s %-10s %-10s" "$name" "$phase" "$ready" "$restarts" "$condition")${NC}"
done <<< "$POD_DATA"


# Check for pods with issues
PROBLEMATIC_PODS=$(echo "$PODS_JSON" | jq -r '
  .items[] |
  select(
    .status.phase != "Running" or
    (.status.containerStatuses // [] | map(.ready) | any(. == false))
  ) |
  .metadata.name
')

if [ -n "$PROBLEMATIC_PODS" ]; then
    print_warning " PODS REQUIRING ATTENTION"
    while IFS= read -r pod; do
        if [ -n "$pod" ]; then
            echo "  â€¢ $pod"

            # Get recent events for this pod
            EVENTS=$(kubectl get events -n "$NAMESPACE" \
                --field-selector involvedObject.name="$pod" \
                --sort-by='.lastTimestamp' \
                -o json 2>/dev/null | \
                jq -r '.items[-3:] | .[] | "    [\(.lastTimestamp // .eventTime)] \(.reason): \(.message)"' 2>/dev/null || echo "    No recent events")

            if [ -n "$EVENTS" ]; then
                echo "$EVENTS"
            fi
        fi
    done <<< "$PROBLEMATIC_PODS"
fi


# Function to check networking for a specific pod
check_pod_networking() {
    local pod_name=$1
    local pod_ip=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.status.podIP}' 2>/dev/null)
    local pod_phase=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.status.phase}' 2>/dev/null)

    print_info "ğŸ” NETWORK CHECK: $pod_name"

    # 1. POD IP AND PORTS
    print_info "ğŸ“ Pod IP: ${pod_ip:-N/A}"

    print_info "ğŸ”Œ Container Ports:"
    kubectl get pod "$pod_name" -n "$NAMESPACE" -o json | jq -r '
      .spec.containers[] |
      "  Container: \(.name)" +
      (if .ports then
        "\n" + (.ports | map("    - Port: \(.containerPort) Protocol: \(.protocol) Name: \(.name // "unnamed")") | join("\n"))
      else
        "\n    No ports defined"
      end)
    ' 2>/dev/null || echo "  No port information available"

    # 2. SERVICES EXPOSING THIS POD
    print_info "ğŸ”— Services:"
    local pod_labels=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o json | jq -c '.metadata.labels' 2>/dev/null)

    local services_found=false
    kubectl get svc -n "$NAMESPACE" -o json 2>/dev/null | jq -r --argjson pod_labels "$pod_labels" '
      .items[] |
      select(.spec.selector != null) |
      select(
        (.spec.selector | to_entries | all(.key as $k | .value as $v | $pod_labels[$k] == $v))
      ) |
      "  âœ“ Service: \(.metadata.name) (Type: \(.spec.type))\n    ClusterIP: \(.spec.clusterIP)\n    Ports: \(.spec.ports | map("\(.port):\(.targetPort)/\(.protocol)") | join(", "))"
    ' | while read -r line; do
        services_found=true
        echo "$line"
    done

    if [ "$services_found" = false ]; then
        print_warning " No services found matching this pod's labels"
    fi

    # 3. ENDPOINT REGISTRATION
    print_info "ğŸ“¡ Endpoint Registration:"
    local found_in_ep=false
    kubectl get endpoints -n "$NAMESPACE" -o json 2>/dev/null | jq -r --arg ip "$pod_ip" '
      .items[] |
      select(.subsets != null) |
      select(.subsets[].addresses != null) |
      select(.subsets[].addresses[].ip == $ip) |
      "  âœ“ Registered in endpoint: \(.metadata.name)"
    ' | while read -r line; do
        if [ -n "$line" ]; then
            found_in_ep=true
            echo "$line"
        fi
    done

    if [ "$found_in_ep" = false ]; then
        print_warning " Pod IP not found in any endpoints (not receiving service traffic)"
    fi

    # 4. INGRESS RESOURCES
    print_info "ğŸŒ Ingress Resources:"
    local ingress_count=$(kubectl get ingress -n "$NAMESPACE" -o json 2>/dev/null | jq '.items | length')

    if [ "$ingress_count" -gt 0 ]; then
        kubectl get ingress -n "$NAMESPACE" -o json 2>/dev/null | jq -r '
          .items[] |
          "  Ingress: \(.metadata.name)\n    Class: \(.spec.ingressClassName // "default")\n    Hosts: \(.spec.rules | map(.host) | join(", "))\n" +
          (.spec.rules[]? | .http.paths[]? | "    Path: \(.path) â†’ \(.backend.service.name):\(.backend.service.port.number // .backend.service.port.name)") +
          (if .spec.tls then "\n    TLS: \(.spec.tls | map(.hosts | join(", ")) | join(", "))" else "" end)
        ' | sed 's/^/  /'
    else
        echo "  No ingress resources in namespace"
    fi

    # 5. DNS CONFIGURATION
    print_info "ğŸ” DNS Configuration:"
    local dns_policy=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.spec.dnsPolicy}' 2>/dev/null)
    echo "  DNS Policy: ${dns_policy:-Default}"

    # Check cluster DNS
    print_info "  Cluster DNS Service:"
    kubectl get svc -n kube-system -l k8s-app=kube-dns -o wide 2>/dev/null | tail -n +2 | sed 's/^/    /' || \
    kubectl get svc -n kube-system -l k8s-app=coredns -o wide 2>/dev/null | tail -n +2 | sed 's/^/    /' || \
    print_warning " Could not find DNS service"

    # Test DNS from running pod
    if [ "$pod_phase" == "Running" ]; then
        local first_container=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.spec.containers[0].name}' 2>/dev/null)

        print_info "  DNS Resolution Test (from pod):"
        if kubectl exec "$pod_name" -n "$NAMESPACE" -c "$first_container" -- nslookup kubernetes.default.svc.cluster.local &>/dev/null; then
            print_success "  âœ“ DNS resolution working (kubernetes.default.svc.cluster.local)"
        else
            print_warning "    DNS resolution failed or nslookup not available"
        fi
    fi

    # 6. NETWORK POLICIES
    print_info "ğŸ›¡ï¸  Network Policies:"
    local netpol_count=$(kubectl get networkpolicy -n "$NAMESPACE" -o json 2>/dev/null | jq '.items | length')

    if [ "$netpol_count" -gt 0 ]; then
        kubectl get networkpolicy -n "$NAMESPACE" -o json 2>/dev/null | jq -r '
          .items[] |
          "  Policy: \(.metadata.name)\n    Pod Selector: \(.spec.podSelector | if . == {} then "All pods" else (to_entries | map("\(.key)=\(.value)") | join(", ")) end)\n    Policy Types: \(.spec.policyTypes | join(", "))\n    Ingress Rules: \(if .spec.ingress then (.spec.ingress | length) else 0 end)\n    Egress Rules: \(if .spec.egress then (.spec.egress | length) else 0 end)"
        '
    else
        echo "  No network policies (all traffic allowed)"
    fi

    # 7. HEALTH PROBES
    print_info "â¤ï¸  Health Probes:"
    kubectl get pod "$pod_name" -n "$NAMESPACE" -o json | jq -r '
      .spec.containers[] |
      "  Container: \(.name)\n" +
      "    Readiness: \(if .readinessProbe then
        (if .readinessProbe.httpGet then "HTTP \(.readinessProbe.httpGet.path):\(.readinessProbe.httpGet.port)"
        elif .readinessProbe.tcpSocket then "TCP :\(.readinessProbe.tcpSocket.port)"
        elif .readinessProbe.exec then "Exec command"
        else "Custom" end)
      else "None" end)\n" +
      "    Liveness: \(if .livenessProbe then
        (if .livenessProbe.httpGet then "HTTP \(.livenessProbe.httpGet.path):\(.livenessProbe.httpGet.port)"
        elif .livenessProbe.tcpSocket then "TCP :\(.livenessProbe.tcpSocket.port)"
        elif .livenessProbe.exec then "Exec command"
        else "Custom" end)
      else "None" end)"
    ' 2>/dev/null

    # 8. CONNECTIVITY TESTS (only for running pods)
    if [ "$pod_phase" == "Running" ]; then
        print_info "ğŸŒ Connectivity Tests:"
        local first_container=$(kubectl get pod "$pod_name" -n "$NAMESPACE" -o jsonpath='{.spec.containers[0].name}' 2>/dev/null)

        # Test kubernetes API
        if kubectl exec "$pod_name" -n "$NAMESPACE" -c "$first_container" -- timeout 3 sh -c 'echo > /dev/tcp/kubernetes.default.svc.cluster.local/443' &>/dev/null; then
            print_success "  âœ“ Kubernetes API reachable"
        else
            print_warning "  âš ï¸  Kubernetes API not reachable"
        fi

        # Test external connectivity
        if kubectl exec "$pod_name" -n "$NAMESPACE" -c "$first_container" -- timeout 3 sh -c 'echo > /dev/tcp/8.8.8.8/53' &>/dev/null; then
            print_success "  âœ“ External connectivity OK (8.8.8.8:53)"
        else
            print_warning "  âš ï¸  External connectivity failed (may be restricted)"
        fi
    else
        print_warning "  âš ï¸  Pod not running - skipping connectivity tests"
    fi

    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
}

# Run network checks for problematic pods
if [ -n "$PROBLEMATIC_PODS" ]; then
    print_info "Running network diagnostics for problematic pods..."
    while IFS= read -r pod; do
        if [ -n "$pod" ]; then
            check_pod_networking "$pod"
        fi
    done <<< "$PROBLEMATIC_PODS"
else
    print_success "âœ“ All pods healthy - skipping detailed network checks"
fi


# Generate JSON output
JSON_OUTPUT=$(echo "$PODS_JSON" | jq \
    --arg scope_id "$SCOPE_ID" \
    --arg namespace "$NAMESPACE" \
    '{
      success: true,
      scope_id: $scope_id,
      namespace: $namespace,
      summary: {
        total_pods: (.items | length),
        by_phase: (.items | group_by(.status.phase) | map({
          phase: .[0].status.phase,
          count: length
        }))
      },
      pods: [.items[] | {
        name: .metadata.name,
        phase: .status.phase,
        ready: (.status.containerStatuses // [] | map(.ready) | all),
        restarts: (.status.containerStatuses // [] | map(.restartCount) | add // 0),
        age: .metadata.creationTimestamp,
        pod_ip: .status.podIP
      }]
    }')

print_success "âœ… Status check completed"
print_info "JSON Output:"
echo "$JSON_OUTPUT" | jq -c '.'