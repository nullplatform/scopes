#!/bin/bash
# Check: Service Port Configuration
# Validates service and container port alignment

# Validate services exist
require_services || return 0

# Read services from pre-collected data
SERVICES=$(jq -r '.items[].metadata.name' "$SERVICES_FILE" 2>/dev/null | tr '\n' ' ')

HAS_PORT_ISSUES=0

for SERVICE_NAME in $SERVICES; do
    # Get service info from pre-collected data
    SERVICE_INFO=$(jq --arg name "$SERVICE_NAME" '.items[] | select(.metadata.name == $name)' "$SERVICES_FILE" 2>/dev/null)

    # Get service ports and targetPorts
    SERVICE_PORTS=$(echo "$SERVICE_INFO" | jq -r '.spec.ports[] | "\(.port):\(.targetPort):\(.name // "unnamed")"')

    if [[ -z "$SERVICE_PORTS" ]]; then
        HAS_PORT_ISSUES=1
        print_error "Service $SERVICE_NAME: No ports defined"
        continue
    fi

    # Get service selector to find pods
    SERVICE_SELECTORS=$(echo "$SERVICE_INFO" | jq -c '.spec.selector')

    if [[ -z "$SERVICE_SELECTORS" || "$SERVICE_SELECTORS" == "null" ]]; then
        print_warning "Service $SERVICE_NAME: No selector, skipping port validation"
        continue
    fi

    # Find pods from pre-collected data that match service selectors
    PODS=$(jq -r --argjson selectors "$SERVICE_SELECTORS" '
               .items[] |
               . as $pod |
               select(
                 $selectors | to_entries | all(.key as $k | .value as $v |
                   $pod.metadata.labels[$k] == $v
                 )
               ) |
               .metadata.name
             ' "$PODS_FILE" 2>/dev/null | tr '\n' ' ')

    if [[ -z "$PODS" ]]; then
        print_warning "Service $SERVICE_NAME: No pods found to validate ports"
        continue
    fi

    # Check first pod for port validation
    FIRST_POD=$(echo "$PODS" | awk '{print $1}')
    POD_INFO=$(jq --arg name "$FIRST_POD" '.items[] | select(.metadata.name == $name)' "$PODS_FILE" 2>/dev/null)

    print_info "Service $SERVICE_NAME port configuration:"

    # Validate configuration and test connectivity
    # Use process substitution to avoid subshell and preserve HAS_PORT_ISSUES updates
    while IFS=':' read -r SERVICE_PORT TARGET_PORT PORT_NAME; do
        ACTUAL_TARGET_PORT="$TARGET_PORT"
        CONTAINER_NAME=""

        # Check if targetPort is numeric or named
        if [[ "$TARGET_PORT" =~ ^[0-9]+$ ]]; then
            # Numeric targetPort - find which container has this port
            CONTAINER_INFO=$(echo "$POD_INFO" | jq -r --arg port "$TARGET_PORT" '
                .spec.containers[] |
                select(.ports[]?.containerPort == ($port | tonumber)) |
                "\(.name):\(.ports[] | select(.containerPort == ($port | tonumber)) | .containerPort)"
            ' | head -1)

            if [[ -n "$CONTAINER_INFO" ]]; then
                CONTAINER_NAME=$(echo "$CONTAINER_INFO" | cut -d':' -f1)
                print_success "  Port $SERVICE_PORT -> $TARGET_PORT ($PORT_NAME): Configuration OK [container: $CONTAINER_NAME]"
            else
                HAS_PORT_ISSUES=1
                # Show available ports per container
                AVAILABLE_PORTS=$(echo "$POD_INFO" | jq -r '.spec.containers[] | "\(.name): \([.ports[]?.containerPort] | join(","))"' | tr '\n' '; ')
                print_error "  Port $SERVICE_PORT -> $TARGET_PORT ($PORT_NAME): Container port $TARGET_PORT not found"
                print_warning "    Available ports by container: $AVAILABLE_PORTS"
                continue
            fi
        else
            # Named port - find which container has this named port
            CONTAINER_INFO=$(echo "$POD_INFO" | jq -r --arg portname "$TARGET_PORT" '
                .spec.containers[] |
                select(.ports[]? | select(.name == $portname)) |
                "\(.name):\(.ports[] | select(.name == $portname) | .containerPort)"
            ' | head -1)

            if [[ -n "$CONTAINER_INFO" ]]; then
                CONTAINER_NAME=$(echo "$CONTAINER_INFO" | cut -d':' -f1)
                ACTUAL_TARGET_PORT=$(echo "$CONTAINER_INFO" | cut -d':' -f2)
                print_success "  Port $SERVICE_PORT -> $TARGET_PORT ($PORT_NAME): Resolves to $ACTUAL_TARGET_PORT [container: $CONTAINER_NAME]"
            else
                HAS_PORT_ISSUES=1
                print_error "  Port $SERVICE_PORT -> $TARGET_PORT ($PORT_NAME): Named port not found in containers"
                continue
            fi
        fi

        # Active connectivity check - verify application is listening on the port
        print_info "    Testing connectivity to port $ACTUAL_TARGET_PORT in container '$CONTAINER_NAME'..."

        # Try to connect to the port from inside the specific container
        CONNECTIVITY_TEST=$(kubectl exec "$FIRST_POD" -n "$NAMESPACE" -c "$CONTAINER_NAME" -- timeout 2 sh -c "command -v nc >/dev/null 2>&1 && nc -z localhost $ACTUAL_TARGET_PORT || (command -v curl >/dev/null 2>&1 && curl -s --max-time 1 localhost:$ACTUAL_TARGET_PORT >/dev/null)" 2>&1)
        CONNECTIVITY_EXIT_CODE=$?

        if [[ $CONNECTIVITY_EXIT_CODE -eq 0 ]]; then
            print_success "    ✓ Port $ACTUAL_TARGET_PORT is accepting connections"
        else
            HAS_PORT_ISSUES=1
            print_error "    ✗ Port $ACTUAL_TARGET_PORT is NOT accepting connections"
            print_warning "    Configuration is correct but application may not be listening on port $ACTUAL_TARGET_PORT"
            print_info "    Check logs: kubectl logs $FIRST_POD -n $NAMESPACE -c $CONTAINER_NAME"
        fi
    done < <(echo "$SERVICE_PORTS")
done

if [[ $HAS_PORT_ISSUES -eq 0 ]]; then
    update_check_result --status "success" --evidence "{}"
else
    update_check_result --status "failed" --evidence "{}"
fi