#!/bin/bash
# Check: Ingress Host Rules
# Verifies host and path rules are properly configured

# Get ingresses
INGRESSES=$(kubectl get ingress -n "$NAMESPACE" -l "$LABEL_SELECTOR" -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)

if [[ -z "$INGRESSES" ]]; then
    print_error "No ingresses found with labels $LABEL_SELECTOR in namespace $NAMESPACE"
    update_check_result --status "failed" --evidence "{}"
else

  HAS_ISSUES=0

  for INGRESS_NAME in $INGRESSES; do
      INGRESS_INFO=$(kubectl get ingress "$INGRESS_NAME" -n "$NAMESPACE" -o json 2>/dev/null)

      print_info "Checking host rules for ingress: $INGRESS_NAME"

      # Get ingress address/status
      INGRESS_ADDRESS=$(echo "$INGRESS_INFO" | jq -r '.status.loadBalancer.ingress[0].ip // .status.loadBalancer.ingress[0].hostname // empty')

      if [[ -z "$INGRESS_ADDRESS" ]]; then
          print_warning "  Ingress address not yet assigned (still provisioning)"
      else
          print_info "  Ingress address: $INGRESS_ADDRESS"
      fi

      # Check if there are any rules
      RULE_COUNT=$(echo "$INGRESS_INFO" | jq '.spec.rules | length' 2>/dev/null)

      if [[ "$RULE_COUNT" -eq 0 ]]; then
          # Check for default backend
          DEFAULT_BACKEND=$(echo "$INGRESS_INFO" | jq -r '.spec.defaultBackend.service.name // empty')

          if [[ -n "$DEFAULT_BACKEND" ]]; then
              print_success "  Catch-all rule using default backend: $DEFAULT_BACKEND"
          else
              HAS_ISSUES=1
              print_error "  No rules and no default backend configured"
          fi
          continue
      fi

      # Check each rule
      RULES=$(echo "$INGRESS_INFO" | jq -c '.spec.rules[]' 2>/dev/null)

      echo "$RULES" | while read -r RULE; do
          HOST=$(echo "$RULE" | jq -r '.host // "*"')

          # Check if host is defined
          if [[ "$HOST" == "*" ]]; then
              print_warning "  Host: * (catch-all, consider specifying a hostname)"
          else
              print_success "  Host: $HOST"
          fi

          # Check paths
          PATHS=$(echo "$RULE" | jq -c '.http.paths[]' 2>/dev/null)

          if [[ -z "$PATHS" ]]; then
              HAS_ISSUES=1
              print_error "    No paths defined for host $HOST"
              continue
          fi

          echo "$PATHS" | while read -r PATH_RULE; do
              PATH=$(echo "$PATH_RULE" | jq -r '.path // "/"')
              PATH_TYPE=$(echo "$PATH_RULE" | jq -r '.pathType // "Prefix"')
              BACKEND_SERVICE=$(echo "$PATH_RULE" | jq -r '.backend.service.name')
              BACKEND_PORT=$(echo "$PATH_RULE" | jq -r '.backend.service.port.number // .backend.service.port.name')

              print_info "    Path: $PATH ($PATH_TYPE) -> $BACKEND_SERVICE:$BACKEND_PORT"

              # Validate pathType
              if [[ "$PATH_TYPE" != "Exact" && "$PATH_TYPE" != "Prefix" && "$PATH_TYPE" != "ImplementationSpecific" ]]; then
                  HAS_ISSUES=1
                  print_error "      Invalid pathType: $PATH_TYPE (must be Exact, Prefix, or ImplementationSpecific)"
              fi

              # Warn about path conventions
              if [[ "$PATH_TYPE" == "Prefix" && "$PATH" != "/" && ! "$PATH" =~ ^/.*[^/]$ ]]; then
                  print_warning "      Path ends with '/' - this may cause routing issues with Prefix type"
              fi
          done
      done

      # Check for conflicting rules
      HOSTS=$(echo "$INGRESS_INFO" | jq -r '.spec.rules[].host' 2>/dev/null | sort)
      DUPLICATE_HOSTS=$(echo "$HOSTS" | uniq -d)

      if [[ -n "$DUPLICATE_HOSTS" ]]; then
          print_warning "  Duplicate host rules found: $DUPLICATE_HOSTS"
          print_info "    Multiple path rules for the same host are OK, but verify they don't conflict"
      fi
  done

  if [[ $HAS_ISSUES -eq 0 ]]; then
      update_check_result --status "success" --evidence "{}"
  else
      update_check_result --status "failed" --evidence "{}"
  fi
fi