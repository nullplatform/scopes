#!/bin/bash
# Check: Ingress Host Rules
# Verifies host and path rules are properly configured

# Validate ingresses exist
require_ingresses || return 0

# Get ingresses
INGRESSES=$(jq -r '.items[].metadata.name' "$INGRESSES_FILE" 2>/dev/null | tr '\n' ' ')

HAS_ISSUES=0

for INGRESS_NAME in $INGRESSES; do
    INGRESS_INFO=$(jq --arg name "$INGRESS_NAME" '.items[] | select(.metadata.name == $name)' "$INGRESSES_FILE" 2>/dev/null)

    print_info "Checking host rules for ingress: $INGRESS_NAME"

    # Get ingress address/status
    INGRESS_ADDRESS=$(echo "$INGRESS_INFO" | jq -r '.status.loadBalancer.ingress[0].ip // .status.loadBalancer.ingress[0].hostname // empty')

    if [[ -z "$INGRESS_ADDRESS" ]]; then
        print_warning "  Ingress address not yet assigned (still provisioning)"
    else
        print_info "  Ingress address: $INGRESS_ADDRESS"
    fi

    # Check if there are any rules
    RULE_COUNT=$(echo "$INGRESS_INFO" | jq '.spec.rules | length' 2>/dev/null)

    if [[ "$RULE_COUNT" -eq 0 ]]; then
        # Check for default backend
        DEFAULT_BACKEND=$(echo "$INGRESS_INFO" | jq -r '.spec.defaultBackend.service.name // empty')

        if [[ -n "$DEFAULT_BACKEND" ]]; then
            print_success "  Catch-all rule using default backend: $DEFAULT_BACKEND"
        else
            HAS_ISSUES=1
            print_error "  No rules and no default backend configured"
            print_info "  Action: Add at least one rule or configure default backend"
        fi
        continue
    fi

    # Check each rule
    RULES=$(echo "$INGRESS_INFO" | jq -c '.spec.rules[]' 2>/dev/null)

    # Use process substitution to avoid subshell and preserve HAS_ISSUES updates
    while read -r RULE; do
        HOST=$(echo "$RULE" | jq -r '.host // "*"')

        # Check if host is defined
        if [[ "$HOST" == "*" ]]; then
            print_warning "  Host: * (catch-all, consider specifying a hostname)"
        else
            print_success "  Host: $HOST"
        fi

        # Check paths
        PATHS=$(echo "$RULE" | jq -c '.http.paths[]' 2>/dev/null)

        if [[ -z "$PATHS" ]]; then
            HAS_ISSUES=1
            print_error "    No paths defined for host $HOST"
            print_info "    Action: Define at least one path for this host"
            continue
        fi

        # Use process substitution to avoid subshell and preserve HAS_ISSUES updates
        while read -r PATH_RULE; do
            PATH_VALUE=$(echo "$PATH_RULE" | jq -r '.path // "/"')
            PATH_TYPE=$(echo "$PATH_RULE" | jq -r '.pathType // "Prefix"')
            BACKEND_SERVICE=$(echo "$PATH_RULE" | jq -r '.backend.service.name')
            BACKEND_PORT=$(echo "$PATH_RULE" | jq -r '.backend.service.port.number // .backend.service.port.name')

            print_info "    Path: $PATH_VALUE ($PATH_TYPE) -> $BACKEND_SERVICE:$BACKEND_PORT"

            # Validate pathType
            if [[ "$PATH_TYPE" != "Exact" && "$PATH_TYPE" != "Prefix" && "$PATH_TYPE" != "ImplementationSpecific" ]]; then
                HAS_ISSUES=1
                print_error "      Invalid pathType: $PATH_TYPE (must be Exact, Prefix, or ImplementationSpecific)"
                print_info "      Action: Use valid pathType value"
            fi

            # Warn about path conventions
            if [[ "$PATH_TYPE" == "Prefix" && "$PATH_VALUE" != "/" && ! "$PATH" =~ ^/.*[^/]$ ]]; then
                print_warning "      Path ends with '/' - this may cause routing issues with Prefix type"
            fi
        done < <(echo "$PATHS")
    done < <(echo "$RULES")

    # Check for conflicting rules
    HOSTS=$(echo "$INGRESS_INFO" | jq -r '.spec.rules[].host' 2>/dev/null | sort)
    DUPLICATE_HOSTS=$(echo "$HOSTS" | uniq -d)

    if [[ -n "$DUPLICATE_HOSTS" ]]; then
        print_warning "  Duplicate host rules found: $DUPLICATE_HOSTS"
        print_info "    Multiple path rules for the same host are OK, but verify they don't conflict"
    fi
done

if [[ $HAS_ISSUES -eq 0 ]]; then
    INGRESS_COUNT=$(echo "$INGRESSES" | wc -w)
    print_success "Host and path rules valid for all $INGRESS_COUNT ingress(es)"
    update_check_result --status "success" --evidence "{}"
else
    update_check_result --status "failed" --evidence "{}"
fi