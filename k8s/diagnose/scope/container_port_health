#!/bin/bash
# Check: Container Port Health
# Validates that containers are actually listening on their declared ports

# Validate pods exist
require_pods || return 0

# Read pods from pre-collected data
PODS=$(jq -r '.items[].metadata.name' "$PODS_FILE" 2>/dev/null | tr '\n' ' ')

HAS_PORT_ISSUES=0

for POD_NAME in $PODS; do
    # Get pod info from pre-collected data
    POD_INFO=$(jq --arg name "$POD_NAME" '.items[] | select(.metadata.name == $name)' "$PODS_FILE" 2>/dev/null)

    # Check if pod is running
    POD_PHASE=$(echo "$POD_INFO" | jq -r '.status.phase')
    if [[ "$POD_PHASE" != "Running" ]]; then
        print_warning "Pod $POD_NAME: Not running (phase: $POD_PHASE), skipping port checks"
        continue
    fi

    print_info "Checking pod $POD_NAME:"

    # Get all containers with their ports
    CONTAINERS=$(echo "$POD_INFO" | jq -r '.spec.containers[] | @base64')

    for CONTAINER_B64 in $CONTAINERS; do
        CONTAINER_DATA=$(echo "$CONTAINER_B64" | base64 -d)
        CONTAINER_NAME=$(echo "$CONTAINER_DATA" | jq -r '.name')

        # Get declared ports for this container
        CONTAINER_PORTS=$(echo "$CONTAINER_DATA" | jq -r '.ports[]? | .containerPort' | tr '\n' ' ')

        if [[ -z "$CONTAINER_PORTS" ]]; then
            print_info "  Container '$CONTAINER_NAME': No ports declared"
            continue
        fi

        print_info "  Container '$CONTAINER_NAME':"

        # Detect which ports are actually listening in the container
        # Try ss first, then netstat
        LISTENING_PORTS=""
        if kubectl exec "$POD_NAME" -n "$NAMESPACE" -c "$CONTAINER_NAME" -- sh -c "command -v ss >/dev/null 2>&1" 2>/dev/null; then
            LISTENING_PORTS=$(kubectl exec "$POD_NAME" -n "$NAMESPACE" -c "$CONTAINER_NAME" -- sh -c "ss -tlnH 2>/dev/null | awk '{print \$4}' | sed 's/.*://'" 2>/dev/null | sort -u | tr '\n' ' ')
        elif kubectl exec "$POD_NAME" -n "$NAMESPACE" -c "$CONTAINER_NAME" -- sh -c "command -v netstat >/dev/null 2>&1" 2>/dev/null; then
            LISTENING_PORTS=$(kubectl exec "$POD_NAME" -n "$NAMESPACE" -c "$CONTAINER_NAME" -- sh -c "netstat -tln 2>/dev/null | grep LISTEN | awk '{print \$4}' | sed 's/.*://'" 2>/dev/null | sort -u | tr '\n' ' ')
        fi

        if [[ -z "$LISTENING_PORTS" ]]; then
            print_warning "    Cannot detect listening ports in this container, checking connectivity"

            # Fallback to connectivity test
            for PORT in $CONTAINER_PORTS; do
                kubectl exec "$POD_NAME" -n "$NAMESPACE" -c "$CONTAINER_NAME" -- timeout 2 sh -c "command -v nc >/dev/null 2>&1 && nc -z localhost $PORT || (command -v curl >/dev/null 2>&1 && curl -s --max-time 1 localhost:$PORT >/dev/null)" >/dev/null 2>&1
                CONNECTIVITY_EXIT_CODE=$?

                if [[ $CONNECTIVITY_EXIT_CODE -eq 0 ]]; then
                    print_success "    Port $PORT: ✓ Responding"
                else
                    HAS_PORT_ISSUES=1
                    print_warning "    Port $PORT: ⚠ Not responding"
                fi
            done
        else
            # Check each declared port
            for PORT in $CONTAINER_PORTS; do
                if echo "$LISTENING_PORTS" | grep -wq "$PORT"; then
                    print_success "    Port $PORT: ✓ Listening"
                else
                    HAS_PORT_ISSUES=1
                    # Format listening ports nicely for display (remove trailing spaces and convert to comma-separated)
                    FORMATTED_LISTENING=$(echo "$LISTENING_PORTS" | xargs | tr ' ' ',')
                    print_error "    Port $PORT: ✗ Declared but not listening (pod listening on: $FORMATTED_LISTENING)"
                fi
            done
        fi
    done
done

if [[ $HAS_PORT_ISSUES -eq 0 ]]; then
    update_check_result --status "success" --evidence "{}"
else
    update_check_result --status "failed" --evidence "{}"
fi
