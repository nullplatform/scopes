#!/bin/bash
set -euo pipefail

# Query Azure Monitor metrics for App Service (both production and staging slots)

if [ -z "${METRIC_NAME:-}" ]; then
  echo '{"metric":"","type":"","period_in_seconds":0,"unit":"","results":[]}' >&2
  exit 1
fi

# Map nullplatform metric names to Azure Monitor metrics
# Returns: azure_metric aggregation unit type resource_type
# resource_type: "site" or "plan" (plan metrics are shared across slots)
get_azure_metric_config() {
  local metric="$1"
  case "$metric" in
    "system.cpu_usage_percentage")
      echo "CpuPercentage Average percent gauge plan"
      ;;
    "system.memory_usage_percentage")
      echo "MemoryPercentage Average percent gauge plan"
      ;;
    "http.response_time")
      echo "HttpResponseTime Average seconds gauge site"
      ;;
    "http.rpm")
      echo "Requests Total rpm gauge site"
      ;;
    "http.error_rate")
      echo "COMPUTED Total percent gauge site"
      ;;
    "http.request_count")
      echo "Requests Total count gauge site"
      ;;
    "http.5xx_count")
      echo "Http5xx Total count gauge site"
      ;;
    "http.4xx_count")
      echo "Http4xx Total count gauge site"
      ;;
    "system.health_check_status")
      echo "HealthCheckStatus Average percent gauge site"
      ;;
    *)
      echo ""
      ;;
  esac
}

CONFIG=$(get_azure_metric_config "$METRIC_NAME")

if [ -z "$CONFIG" ]; then
  echo "Error: Unknown metric: $METRIC_NAME" >&2
  exit 1
fi

AZURE_METRIC=$(echo "$CONFIG" | cut -d' ' -f1)
AGGREGATION=$(echo "$CONFIG" | cut -d' ' -f2)
UNIT=$(echo "$CONFIG" | cut -d' ' -f3)
METRIC_TYPE=$(echo "$CONFIG" | cut -d' ' -f4)
RESOURCE_TYPE=$(echo "$CONFIG" | cut -d' ' -f5)

# Calculate interval
INTERVAL_MINUTES=${INTERVAL:-5}
PERIOD_SECONDS=$((INTERVAL_MINUTES * 60))
TIMESPAN="${START_TIME}/${END_TIME}"

# Resource IDs
PROD_RESOURCE_ID="$AZURE_RESOURCE_ID"
STAGING_RESOURCE_ID="${AZURE_RESOURCE_ID}/slots/staging"

# Get App Service Plan ID (for plan-level metrics)
get_plan_id() {
  local SITE_URL="https://management.azure.com${AZURE_RESOURCE_ID}?api-version=2022-03-01"
  local SITE_INFO
  SITE_INFO=$(curl -s "$SITE_URL" \
    -H "Authorization: Bearer ${AZURE_ACCESS_TOKEN}" \
    -H "Content-Type: application/json")
  echo "$SITE_INFO" | jq -r '.properties.serverFarmId // empty'
}

# Query Azure Monitor via REST API
query_metric() {
  local metric="$1"
  local aggregation="$2"
  local resource_id="$3"

  local METRICS_URL="https://management.azure.com${resource_id}/providers/microsoft.insights/metrics"

  curl -s "${METRICS_URL}?api-version=2018-01-01&metricnames=${metric}&aggregation=${aggregation}&timespan=${TIMESPAN}&interval=PT${INTERVAL_MINUTES}M" \
    -H "Authorization: Bearer ${AZURE_ACCESS_TOKEN}" \
    -H "Content-Type: application/json" 2>/dev/null || echo '{"value":[]}'
}

# Transform Azure Monitor response to standard format with slot selector
transform_response() {
  local response="$1"
  local aggregation_key="$2"
  local slot="$3"

  echo "$response" | jq --arg agg "$aggregation_key" --arg slot "$slot" '
    if (.value[0].timeseries | length) > 0 then
      [.value[0].timeseries[] | {
        selector: {slot: $slot},
        data: [
          .data[] |
          select(.[$agg] != null) |
          {
            timestamp: .timeStamp,
            value: .[$agg]
          }
        ]
      }]
    else
      []
    end
  ' 2>/dev/null || echo '[]'
}

AGG_KEY=$(echo "$AGGREGATION" | tr '[:upper:]' '[:lower:]')

if [ "$RESOURCE_TYPE" = "plan" ]; then
  # Plan-level metrics (CPU/Memory) - shared across all slots
  PLAN_ID=$(get_plan_id)
  if [ -z "$PLAN_ID" ]; then
    echo "Error: Could not get App Service Plan ID from site" >&2
    exit 1
  fi

  RESPONSE=$(query_metric "$AZURE_METRIC" "$AGGREGATION" "$PLAN_ID")
  RESULTS=$(transform_response "$RESPONSE" "$AGG_KEY" "all")

elif [ "$METRIC_NAME" = "http.error_rate" ]; then
  # Special case: compute Http5xx / Requests * 100 for each slot
  # Production
  PROD_5XX=$(query_metric "Http5xx" "Total" "$PROD_RESOURCE_ID")
  PROD_REQ=$(query_metric "Requests" "Total" "$PROD_RESOURCE_ID")

  PROD_RESULTS=$(jq -n \
    --argjson r5xx "$PROD_5XX" \
    --argjson rreq "$PROD_REQ" \
    'if ($r5xx.value[0].timeseries | length) > 0 then
      [{
        selector: {slot: "production"},
        data: [
          range($r5xx.value[0].timeseries[0].data | length) |
          . as $i |
          {
            timestamp: $r5xx.value[0].timeseries[0].data[$i].timeStamp,
            value: (
              if ($rreq.value[0].timeseries[0].data[$i].total // 0) > 0 then
                ($r5xx.value[0].timeseries[0].data[$i].total // 0) / ($rreq.value[0].timeseries[0].data[$i].total) * 100
              else
                0
              end
            )
          }
        ]
      }]
    else [] end' 2>/dev/null || echo '[]')

  # Staging (may not exist)
  STAGING_5XX=$(query_metric "Http5xx" "Total" "$STAGING_RESOURCE_ID")
  STAGING_REQ=$(query_metric "Requests" "Total" "$STAGING_RESOURCE_ID")

  STAGING_RESULTS=$(jq -n \
    --argjson r5xx "$STAGING_5XX" \
    --argjson rreq "$STAGING_REQ" \
    'if ($r5xx.value[0].timeseries | length) > 0 then
      [{
        selector: {slot: "staging"},
        data: [
          range($r5xx.value[0].timeseries[0].data | length) |
          . as $i |
          {
            timestamp: $r5xx.value[0].timeseries[0].data[$i].timeStamp,
            value: (
              if ($rreq.value[0].timeseries[0].data[$i].total // 0) > 0 then
                ($r5xx.value[0].timeseries[0].data[$i].total // 0) / ($rreq.value[0].timeseries[0].data[$i].total) * 100
              else
                0
              end
            )
          }
        ]
      }]
    else [] end' 2>/dev/null || echo '[]')

  RESULTS=$(jq -n --argjson prod "$PROD_RESULTS" --argjson staging "$STAGING_RESULTS" '$prod + $staging')

elif [ "$METRIC_NAME" = "http.rpm" ]; then
  # Special case: Total requests / interval_minutes for each slot
  PROD_RESPONSE=$(query_metric "Requests" "Total" "$PROD_RESOURCE_ID")
  PROD_RESULTS=$(echo "$PROD_RESPONSE" | jq --argjson interval "$INTERVAL_MINUTES" '
    if (.value[0].timeseries | length) > 0 then
      [.value[0].timeseries[] | {
        selector: {slot: "production"},
        data: [
          .data[] |
          select(.total != null) |
          {
            timestamp: .timeStamp,
            value: (.total / $interval)
          }
        ]
      }]
    else [] end' 2>/dev/null || echo '[]')

  STAGING_RESPONSE=$(query_metric "Requests" "Total" "$STAGING_RESOURCE_ID")
  STAGING_RESULTS=$(echo "$STAGING_RESPONSE" | jq --argjson interval "$INTERVAL_MINUTES" '
    if (.value[0].timeseries | length) > 0 then
      [.value[0].timeseries[] | {
        selector: {slot: "staging"},
        data: [
          .data[] |
          select(.total != null) |
          {
            timestamp: .timeStamp,
            value: (.total / $interval)
          }
        ]
      }]
    else [] end' 2>/dev/null || echo '[]')

  RESULTS=$(jq -n --argjson prod "$PROD_RESULTS" --argjson staging "$STAGING_RESULTS" '$prod + $staging')

else
  # Standard site-level metrics - query both slots
  PROD_RESPONSE=$(query_metric "$AZURE_METRIC" "$AGGREGATION" "$PROD_RESOURCE_ID")
  PROD_RESULTS=$(transform_response "$PROD_RESPONSE" "$AGG_KEY" "production")

  STAGING_RESPONSE=$(query_metric "$AZURE_METRIC" "$AGGREGATION" "$STAGING_RESOURCE_ID")
  STAGING_RESULTS=$(transform_response "$STAGING_RESPONSE" "$AGG_KEY" "staging")

  RESULTS=$(jq -n --argjson prod "$PROD_RESULTS" --argjson staging "$STAGING_RESULTS" '$prod + $staging')
fi

# Output in standard format
jq -n \
  --arg metric "$METRIC_NAME" \
  --arg type "$METRIC_TYPE" \
  --argjson period "$PERIOD_SECONDS" \
  --arg unit "$UNIT" \
  --argjson results "$RESULTS" \
  '{
    metric: $metric,
    type: $type,
    period_in_seconds: $period,
    unit: $unit,
    results: $results
  }'
